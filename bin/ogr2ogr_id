#!/usr/bin/env bash
set -euo pipefail

# Usage: ogr2ogr_id ID
# Robust wrapper to run the same ogr2ogr command as in the Rakefile for one ID.
# Features:
# - forwards SIGINT/SIGTERM to the ogr2ogr child
# - monitors the original parent PID and kills the child if the parent disappears
# Expects DATA_DIR and optionally RUN env var to be set. Defaults:
DATA_DIR="${DATA_DIR:-data}"
if [ "$#" -lt 1 ]; then
  echo "Usage: $0 ID" >&2
  exit 2
fi
ID="$1"

mkdir -p "$DATA_DIR"

SQL="SELECT poly.*, gcluster.* FROM Poly_${ID} poly LEFT JOIN '/vsizip/vsicurl/https://gisstar.gsi.go.jp/terrain2021/Poly_${ID}.zip/Poly_${ID}/GlobalCluster_${ID}.dbf'.GlobalCluster_${ID} gcluster ON poly.polyID = gcluster.POLYID"

OUTFILE="$DATA_DIR/${ID}.fgb"
SRC="/vsizip/vsicurl/https://gisstar.gsi.go.jp/terrain2021/Poly_${ID}.zip/Poly_${ID}/Poly_${ID}.shp"

echo "ID=${ID} -> ${OUTFILE}"

# If the outfile already exists and looks non-empty, skip regeneration to save time.
if [ -s "${OUTFILE}" ]; then
  echo "Output ${OUTFILE} already exists and is non-empty; skipping generation for ID=${ID}"
  exit 0
fi

if [ "${RUN:-0}" != "1" ]; then
  echo "(dry-run) not executing ogr2ogr for ID=${ID}"
  echo "ogr2ogr -f FlatGeobuf -nlt PROMOTE_TO_MULTI -skipfailures -progress -sql \"${SQL}\" \"${OUTFILE}\" \"${SRC}\""
  exit 0
fi

# Temp output file (unique per process) to avoid leaving partial files if interrupted
# Ensure the temp outfile ends with .fgb so ogr2ogr writes a flatgeobuf file
# and doesn't create a directory dataset (which happens when the name lacks the .fgb extension).
TMP_OUTFILE="${OUTFILE}.tmp.$$.fgb"


# Remember the parent PID (the process that launched this script). If that PID disappears
# we assume the controller died and we should kill the child to avoid orphaned ogr2ogr.
CONTROLLER_PID=$PPID

kill_child_and_exit() {
  if [ -n "${CHILD_PID:-}" ]; then
    echo "Terminating ogr2ogr (pid ${CHILD_PID})"
    kill -TERM "${CHILD_PID}" 2>/dev/null || true
    # give it a moment
    sleep 2
    kill -KILL "${CHILD_PID}" 2>/dev/null || true
  fi
  # clean up any temporary outfile left behind by this process
  if [ -n "${TMP_OUTFILE:-}" ] && [ -f "${TMP_OUTFILE}" ]; then
    echo "Removing temporary outfile ${TMP_OUTFILE}" >&2
    rm -f "${TMP_OUTFILE}" || true
  fi
  exit 130
}

trap 'kill_child_and_exit' INT TERM

## Retry wrapper for ogr2ogr
# Environment variables to control retry behavior:
# OGR2OGR_RETRIES: number of additional attempts after the first (default: 2)
# OGR2OGR_BACKOFF: seconds to sleep between attempts (default: 5)
if [ -z "${OGR2OGR_RETRIES:-}" ]; then
  RETRIES=2
else
  RETRIES="${OGR2OGR_RETRIES}"
fi

if [ -z "${OGR2OGR_BACKOFF:-}" ]; then
  BACKOFF=5
else
  BACKOFF="${OGR2OGR_BACKOFF}"
fi

attempt=0
while :; do
  attempt=$((attempt+1))
  echo "Starting ogr2ogr attempt ${attempt}/$((RETRIES+1)) for ID=${ID} -> ${OUTFILE}"

  # Start ogr2ogr as a child so we can manage it
  # write to a temp file first (with .fgb extension), then rename into place on success to ensure atomicity
  TMP_OUTFILE="${OUTFILE}.tmp.$$.fgb"
  ogr2ogr -f FlatGeobuf -nlt PROMOTE_TO_MULTI -skipfailures -progress -sql "${SQL}" "${TMP_OUTFILE}" "${SRC}" &
  CHILD_PID=$!

  # Monitor loop: wait for child, and also check if controller PID is gone (reparented to 1)
  while kill -0 "${CHILD_PID}" 2>/dev/null; do
    # If controller disappeared, kill child and exit
    if ! ps -p "${CONTROLLER_PID}" >/dev/null 2>&1; then
      echo "Controller PID ${CONTROLLER_PID} disappeared; killing child ${CHILD_PID} to avoid orphaning"
      kill_child_and_exit
    fi
    sleep 1
  done

  # Wait for the child to reap and return its exit code
  wait ${CHILD_PID}
  ret=$?
  if [ $ret -eq 0 ]; then
    # Move tmp into final place atomically
    mv -f "${TMP_OUTFILE}" "${OUTFILE}"
    echo "ogr2ogr succeeded for ID=${ID} on attempt ${attempt}; moved ${TMP_OUTFILE} -> ${OUTFILE}"
    exit 0
  fi

  echo "ogr2ogr failed for ID=${ID} on attempt ${attempt} (exit $ret)" >&2

  if [ ${attempt} -le ${RETRIES} ]; then
    echo "Retrying in ${BACKOFF} seconds..."
    # ensure any leftover child is killed
    if kill -0 "${CHILD_PID}" 2>/dev/null; then
      kill -TERM "${CHILD_PID}" 2>/dev/null || true
      sleep 2
      kill -KILL "${CHILD_PID}" 2>/dev/null || true
    fi
    # remove temporary outfile on failure so subsequent attempts start clean
    if [ -f "${TMP_OUTFILE}" ]; then
      rm -f "${TMP_OUTFILE}" || true
    fi
    sleep ${BACKOFF}
    continue
  else
    echo "All attempts exhausted for ID=${ID}. Giving up." >&2
    # cleanup temporary file if present
    if [ -f "${TMP_OUTFILE}" ]; then
      rm -f "${TMP_OUTFILE}" || true
    fi
    exit $ret
  fi
done
